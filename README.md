# 2022年度オブジェクト指向プログラミング 最終課題

以下のレースゲームのシミュレーションを行うプログラムを作成せよ。
また、そのプログラムに関して、実装した範囲および仕様以外の拡張（AIの追加やルールの拡張）を行った箇所について、説明を`Report.txt`に記せ。特に拡張を行った場合、必ず入力方法を記述せよ。仕様を過不足無く実装した場合はそのように記述すること。
「過不足ない」とは「指定されたものは全て」かつ「指定されたもの以外には何もない」の意味であることに注意せよ。<!-- ときどき、「過不足無く実装した。拡張は...」のようなレポートを見かけて脱力するので。 -->




## 締め切り
2/8(水) 23:59（日本時間）


## 課題の概要

マスが一直線に並んだレーンで行うターン制のレースをシミュレーションする。
入力はレースのフィールドおよびランナーの設定であり、ランナーが一人ゴールするまでの各ターンのランナーの選択および実行後の状態をログとして出力する。

採点はログに対して行うので、「ランナーが起こし得ない事象」については実装しなくても良いことに注意すること。

`oop.ex5.Runner`という抽象クラスが既に定義されているが、**これを利用することは必須ではない**ことに注意すること。
用いても構わないが、使用不使用は一切加点減点の対象にはならない。
あくまでおまけのために作られたものである。




## 用語

ここでは便宜上、上や左右などの表現を使っているが、X軸方向やY軸方向（の負方向、正方向）程度の意味である。

- **フィールド**は2つ以上のレーンで構成される。
- **レーン**はスタートラインからまっすぐ上に伸びたコースである。同フィールド内のレーンはマスが平行かつ左右に等間隔に並んでいる。各レーンは**左から順に**0,1,2,...と番号付けされている。
- **距離**はマスの番号である。各レーンのマスは0から始まり、上に行く毎に番号が1ずつ増加する。（同じ距離のマスは横に揃っている）
- **ゴール**はレーン上の特定の距離のマスである。フィールド上の全てのレーンは同じ番号のマスをゴールとする。なお、これはレースでありすごろくではないので、特定の距離を**超えた場合**もゴールしたものと見なす。
- **ランナー**はゴールを目指してレーン上を進む。各ランナーはマス一つを占有し、同じ領域に二人いることはできない。初期位置のマスは全て距離0のマスである。
- **スタミナ**はランナーがターン毎に消費するポイントである。あるレースにおける全てのランナーは同じスタミナで開始する。スタミナは消費するだけであり回復しない。
- **コマンド**はランナーが次のターンにどのような動きをするかを決めるものである。コマンドによって消費するスタミナが異なる（ただし消費が0のコマンドもある）。
- **疲労度**はコマンドの選択によって蓄積する値である。疲労度が増加するとコマンドの消費スタミナが増加する。疲労度はレース開始からそこまでのスタミナの使用量である。

## パラメータ制限

- レーン数`L`：`1 <= L < 20`
- ランナー数`R`：`1 <= R <= L`
- ゴール番号`G`：`1 <= G <= 1000`
- 初期スタミナ`S`：`0 <= S <= G*G/10`



## コマンドの種類

ランナーが各ターンに取れるコマンドは以下の通り。

- 0: 1マス上に直進する。消費スタミナは常時0。
- 1: 1マス上に直進して1つ左のレーンに移る。初期消費スタミナ1。
- 2: 1マス上に直進して1つ右のレーンに移る。初期消費スタミナ1。
- 3: 2マス上に直進する。初期消費スタミナ1。
- 4: 2マス上に直進して1つ左のレーンに移る。初期消費スタミナ2。
- 5: 2マス上に直進して1つ右のレーンに移る。初期消費スタミナ2。
- 6: 3マス上に直進する。初期消費スタミナ4。
- 7: 3マス上に直進して1つ左のレーンに移る。初期消費スタミナ5。
- 8: 3マス上に直進して1つ右のレーンに移る。初期消費スタミナ5。

スタミナを1以上消費するコマンドは、疲労度によって消費スタミナが変化する。

- 左右に移動するコマンド（上記1,2,4,5,7,8）は疲労度50毎に1ずつ消費スタミナが増加する。
- 2マス上に直進するコマンド（上記3,4,5）は疲労度100毎に1ずつ消費スタミナが増加する。
- 3マス上に直進するコマンド（上記6,7,8）は疲労度20毎に1ずつ消費スタミナが増加する。

上記の二つ以上該当する場合はそれぞれの加算とする。
疲労度150の場合、例えばコマンド4と5は消費ポイントが6（初期2+左右3+2マス1）となり、7と8は消費ポイントが15(初期5+左右3+3マス7)となる。
なお、ゴール番号が1000のコースを全てコマンド6で進めるにはスタミナが8億強必要となるので諦めること（この時点のコマンド6の消費スタミナは4千万越え）。
<!-- 長距離を全力疾走する生物はいない -->


## 移動判定

ランナーのコマンド毎の動作は以下のように規定される。

- コマンド決定後、全てのランナーが選んだコマンドにしたがって直進する。同じレーンの前を走るランナーを追い越すことはできない。直進後の位置が同じか追い越してしまう場合、後ろのランナーは前のランナーの1つ後ろに留まる。
- 直進後の位置から左右の移動を行う。左右の移動で他のランナーと交差することや同じマスに残ってしまうことは許されず、以下の衝突判定が行われる。なお、両端のレーンで外側に移動しようとした場合はその場に留まるものとする。
  - 移動先に留まった別のランナーがいる場合、自身はその場に留まる。このとき、衝突先のランナーにのみ衝突フラグが立つ。（この場合は自身には付かない）
  - 移動先から自分のいた場所に向かってランナーが移動した場合（交差した場合）、自身も相手も元の場所に留まる。このとき、両ランナーに衝突フラグが立つ。
  - 移動先が同じ逆方向から来た別のランナーがいる場合、自身も相手も元の場所に留まる。このときも両ランナーに衝突フラグが立つ。
- 衝突フラグが立ったランナーは、次のターンでコマンド0以外を選べない。コマンド決定後に衝突フラグは消滅する。
  - コマンドを実行中に再度衝突されればフラグがもう一度立つ。

他と衝突して留まった場合も、他のランナーの衝突判定に用いられるので注意。
なお、横に並んだランナーが同じ方向に動くのは（他と衝突しない限り）問題なく移動できる。



## ランナーの種類

ランナーはコマンド選択を行ういくつかの種類に分けられる。
番号は入力にも用いるので注意。
また、どのランナーも「スタミナの関係でどれも選択できない場合」は強制的に0を選ぶものとする。
誤って足りないはずのコマンドを選択した場合（正確にはそれが**出力された**場合）は減点される。

- 0: 常にコマンドの0を選ぶ。
- 1: スタミナが足りるならば3を選ぶ。足りなければ0を選ぶ。
- 2: スタミナが足りるならば6を選ぶ。足りない場合に、3を選ぶのに足りるならば3を選ぶ。それも足りなければ0を選ぶ。
- 3: ターン毎に8から0までを順に選ぶ。0を選ぶと次は8を選ぶ。スタミナが足りず選べなかった場合はそのコマンドをスキップして次のコマンドを選ぶ。
- 4: 自身が左端のレーンにいない場合、7、4、1の順に優先して選ぶ。左端のレーンにいる場合は、3,0の順に優先して選ぶ。（6は選ばないことに注意）
- 5: 初期のレーンが左半分なら右に2回、右半分なら左に2回動く（中央は右半分とする）。2回移動した後または移動方向の端に到達した場合に左右の移動をやめる。上方向は左右の移動中はできる限り大きく動く。左右の移動が終わったら0を選ぶ。残りの距離がスタミナ以下になったら3を選ぶ。
- 6: 自身の左右にランナーがいる場合、2マス前進＋ランナーがいる方向へ進む（両方いる場合は左側を優先）、スタミナが足りない場合は1マス前進＋ランナーがいる方向へ進む。どちらもいなければ3を選ぶ。
- 7: 自身の左右の一つ後ろ（下）、隣、一つ前（上）にランナーがいる場合、3マス前進＋ランナーがいる方向へ進む。左右のどちらもいる場合、見た範囲の先頭がより後方である方、どちらも同じ距離ならば左を優先する。3マス前進のスタミナが足りなければ左右移動は諦めて3を選ぶ。左右にいない場合も3を選ぶ。
- 8: 最初は2回6を選ぶ（選べない場合は3,0の順に減らす）。以降は3を選ぶが、自分の前方に他のランナーがいた場合はその距離が2以上離れていれば4か5を（左右の一方にランナーがいればいない方を選び、どちらもいる場合は右を、どちらもいない場合は左を選ぶ）、1しか離れていない（またはスタミナの関係で4や5を選べない）ならば1か2を（基準は4や5と同じ）選ぶ。

どれも決して頭は良くないが気にしないこと。


## 入力フォーマット

全体は2行で表される。

- 1行目は3つの数が空白区切りで与えられ、前から順にレーン数`L`、ゴール番号`G`、初期スタミナ`S`を表す。
- 2行目はレーン数の分だけ数が並んでおり、i番目が0-8の場合「ランナーの種類」で説明したランナーがレーン番号i-1にいることを表す。i番目が-1の場合そこにはランナーがいないことを表す。

パラメータで説明したランナー数`R`が入力に存在しないが、2行目でカウントできる。なおランナー数の範囲からわかる通り、必ず-1以外が入っているレーンが存在する。
ランナーは「左から数えて何番目か（0始まり）」をその番号とする。出力では番号を用いる。

## 出力フォーマット

出力は、各ランナーの状態を表すブロックと、次に各ランナーが実行するコマンドを表すブロックの二つが交互に出現する。
これらは「ランナーの誰かがゴールに到達するまで」繰り返され、その「状態を表すブロック」で出力は終了する。
状態を表すブロックは開始時点の0ターンから始まる。
そのため、以下のような順でブロックが表示される。

- 0 ターン目の状態を表すブロック
- 1 ターン目に実行するコマンドを表すブロック
- 1 ターン目のコマンド終了後の状態を表すブロック
- 2 ターン目に実行するコマンドを表すブロック
- 2 ターン目のコマンド終了後の状態を表すブロック
- ...
- n ターン目に実行するコマンドを表すブロック
- n ターン目のコマンド終了後の状態を表すブロック（初めてゴールに到達しているランナーがいる）

必ず全体が1以上前に進むので、`n`は高々`G`である。
ブロックの間には空行などは入らず、ブロックの末端の次の行は次のブロックの最初の行か、出力の末端である。

「状態を表すブロック」は以下の`R+1`行で構成される。

- 1行目はターン数を表す。iターン目は`State i`という文字列で構成される。（23ターン目なら`State 23`と表示される）
- 残りの`R`行は0番目のランナーから順に、各ランナーの状態を1行ずつで表す。状態は、レーン番号、今いるマスの距離、残りスタミナ、疲労度、衝突の有無（true->1、false->0）の5つの数が空白区切りで並んでいるものとする。

「実行するコマンドを表すブロック」は以下の`R+1`行で構成される。

- 1行目はターン数を表す。iターン目は`Command i`という文字列で構成される。
- 残りの`R`行は0番目のランナーから順に、各ランナーの実行しようとしているコマンドを1行ずつ表示する。コマンドは番号とする。

全体は`(2n+1)*(R+1)`行で構成される。


## プログラムの入出力

入出力は常にファイルに対して行う。
入力は実行時引数の第1引数として与え、出力はその後ろに`.log`というファイル名を付けたものとする。
例えば以下のコマンド

	> java Main5 sample0-1.txt

を実行すると、`sample0-1.txt`というファイルから入力を読み込み、`sample0-1.txt.log`というファイルに出力フォーマットに従った出力を書き込む。
なお、引数を与えなかった場合や2つ以上与えた場合の挙動は自由にして良い。（例えば0の場合特定のファイルを対象にする、2つで出力先を決定する、複数与えて順に実行する、など）
また、標準入出力やエラー出力の利用についても特に限定はしない。 <!-- ただし物理精神問わず攻撃はしないこと -->


## 入出力例

入力例は`sample0-x.txt`から`sample4-x.txt`まで用意されている。（xは0から始まり、いくつか存在）
対応する出力例は`sample0-x_output.txt`から`sample4-x_output.txt`である。（上書きされないようにわざと上の名前付けと異なるようにしている）

それぞれの入力例の使っている機能は以下の通りである。

- `sample0-x.txt`：全てのランナーは0であり、常に`S`は0である。
- `sample1-x.txt`：ランナーは0,1,2のどれかである。パラメータは様々なものが用いられる。
- `sample2-x.txt`：ランナーは0--5のどれかである。衝突が起こらないように調整されているが、前に人がいて進めないことがある。
- `sample3-x.txt`：ランナーは0--5のどれかである。衝突も発生する。
- `sample4-x.txt`：ランナーは0--8のどれかである。最後の例は距離を最大の1000にしている。

採点についても大まかにはこの分類に従って行う。


## 拡張（オプショナル）

ランナーを追加、コース設定、コマンドを自由に追加して良い。
ただし規定のランナーのコマンド選択やコース設定の入出力に影響がないようにすること（入力の番号を重ならないようにして処理を分ける、など）。

ランナーを追加する際には、以下のことに注意せよ。
ランナーはコマンド選択において、他のランナーの位置を利用してもよいが、スタミナや疲労度、選択するコマンドは見ないこと。 <!-- エスパー作られても... -->
コマンドは過去から現時点までのどれも参照できないが、例えば過去の位置は覚えておいてもよい。




## 制限事項

以下の制限事項に違反する場合、本課題の点数は自動で0点となるので注意すること。

+ `Main`と`Runner`以外のクラスを最低でも3つ定義すること。ただしこの講義は設計の講義ではないため、クラスの設計内容に関しては評価の対象としない。
+ `Main`以外のクラスは無名パッケージ以外のパッケージ内に存在すること。（パッケージ名は指定しないので自由に設定せよ）
+ 入力例に対して出力例を読み込むなど、明らかにシミュレーションをしていないような実装をしないこと。

なお、盗用・剽窃などの行為を行った場合には本課題だけでなく本講義の得点そのものを0点とする。


## 注意事項

+ 入力は正しく条件を満たす場合に動作すれば十分だが、正しくない入力（パラメータや番号が範囲外など）に対してプログラムを停止させるかエラーメッセージを出力して続行するかなどは自由に決めてよい。




## おまけ：最強のランナーを目指して

これはオプショナルですらなく、解答したからといって加点されるとは限らないものである。
そのため、あまりこの問題に時間をかけることは勧めない。
本課題に取りかかる場合は、必ず`Report.txt`にその旨を記載すること。指定通りのクラスが存在していても`Report.txt`に書かれていなければ採点対象とはしない。

拡張とは別に、以下の条件を満たすランナーを作成してもよい。このクラスを上の「拡張」に含めるかは自由で良いが、含める場合以下の仕様を逸脱しないように実装すること。（「拡張」に含まれるクラスと同じことをする別のクラスでも良いが、単体でコンパイル可能にすること）

- クラス名 `oop.ex5.RunnnerXXXXX` （`XXXXX`は学籍番号の下5桁）、パッケージは`oop.ex5`
- 抽象クラスである`oop.ex5.Runner`を継承し、`selectCommand`メソッドを実装
  - 各フィールドについて：
    - `lane`：現在のランナーのいるレーン番号
    - `dist`：現在のランナーの距離
    - `stamina`：現在のランナーの残りスタミナ
    - `tiredness`：現在のランナーの疲労度
    - `collision`：衝突されたか
    - `goal`：ゴールのある距離（スタートからゴールまでの距離）
    - `laneNum`：全体のレーン数
  - 実装されているメソッドの説明は省略
  - `selectCommand`：現在の状態から用いるコマンド（0--8）を返す、引数は（自分を含めた）ランナー全員の入った配列。配列はランナーの数と同じ長さを持ち、各々のindexには異なるランナーが入っている。引数の配列は書き換えてはならない。並び替えをしたい場合は別の配列を用意してコピーした上で行うこと。 <!-- C++と違い、Javaでは配列の参照先が書き換えられないことすら指示できない -->
- コンストラクタは`public RunnerXXXXX(int goal, int laneNum, int lane, int stamina)`とする。同じパラメータ順で`Runner`のコンストラクタに渡すこと。ただし、コンストラクタの処理に1秒かかってはならないものとする。
  - `super`の呼び出し後に処理を行ってもよいが、パラメータを変更して`Runner`に渡してはならない
- `moveUp`、`moveLeft`、`moveRight`、`decreaseStamina`、`setCollision`、`getCommand`メソッドは直接・間接を問わず使用不可
  - これらはシミュレーション側が制御するためのメソッドである
- 他のランナーには`getLane`メソッドおよび`getDist`メソッドのみを使用
  - 他者のスタミナや疲労度や衝突の有無を盗み見てはならない
  - 他者の選ぶコマンドを見てはならない
  - 他者を勝手に動かしてはならない
  - リフレクションAPIや`instanceof`演算子などのキャストは厳禁
- 一度の`getCommand`メソッド呼び出し（≒`selectCommand`メソッドの呼び出し）が3秒以内に終わる
  - ノイズレベルの時間のずれは許容します
- シングルスレッドで動作する <!-- これを許容したらいくら計算資源があっても足りません -->
- `selectCommand`メソッドの選ぶコマンドでスタミナが0未満にならない
  - なお消費スタミナについては（計算する部分も課題のうちなので）選択したコマンドに対して外部で計算し、減少処理だけを強制している
  - 項目に違反すると`RuntimeException`が投げられ、レースから除外される
- 課題の仕様としてあげられた範囲のコマンドのみを使用
- Javaファイルが（Java SEの標準ライブラリと`Runner`さえあれば）単体でコンパイル可能
  - `Runner`を編集すると、本番では出題者の手元にあるオリジナルを用いるのでコンパイルエラーが発生して対象から除外される可能性が高いことを留意せよ
- 1インスタンスでメモリを過剰に使わない <!-- これを許容したらいくらメモリがあっても足りません -->
  - 256MBくらいまでは許容するが、1GBはさすがにつらい

解答に含まれるこのランナーは、解答者のうち仕様を満たすコードを集めた上で、出題者の作ったシミュレーションプログラム（+時間計測）上で実行する。
パラメータについては後に決定するが、短距離（`G = 50`）、中距離（`G = 200`）、長距離（`G = 800`）で行う。
レーンの決定（レーン数およびランナー数、各ランナーのレーン番号）は完全に無作為に行うので、自分のランナーにとって都合が悪かったと言われても出題者は責任を負わない。
結果はランナーの番号を1から順に割り振って結果が追えるようにしたものを公開し、解答者にはT2SCHOLAを通して個別に番号を通知する。

各レースに対して以下のような加点をする。（具体的に"1"がどの程度の点数になるかは未定）
なお、ここで言う1位は「シミュレーション終了時点でゴールにいた」ランナー全員のことを指す。

- 多数（10人以上）の場合予選と本選に分け、予選通過（1位のみ）：+1
- 予選と本選を分けない場合、レースの上位半分：+1 （同じ距離のランナーが複数いる場合は半数を超える可能性もある）
- 全体で1位：+2

なお、実行時エラーを起こしたりタイムアウトしたランナーはレース単位で除外する。
また制限に違反したランナーはレースの対象としない。

乱数は使用して良い。ただし他のランナーも利用する可能性があることに注意せよ。


